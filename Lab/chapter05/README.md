# 실습과제 5장 \) 가상 메모리 구현

4장에서 구현한 스케줄링을 확장하여 가상 메모리 관련 기능을 추가해보자. 매 타임 틱마다 자식 프로세스는 20개의 가상 메모리 주소를 참조한다고 가정한다. 참조한 가상 주소는 IPC를 통해 부모 프로세스에게 한꺼번에 전달된다.

부모 프로세스는 자식 프로세스의 PCB에 페이지 테이블 정보를 포함한다. 자식 프로세스의 주소 공간과 물리 주소 공간의 크기는 적절하게 설정한다.

요청된 메모리 접근에 대해 현재 실행 중인 프로세스의 페이지 테이블을 참조하여 해당 가상 주소가 매핑된 실제 물리 주소를 출력한다.

각 프로세스는 독립적인 페이지 테이블을 갖도록 구성하며, 프로세스 간에 공유되는 영역이 없도록 설정한다. 실행 후 1,000 타임 틱 동안 각 프로세스의 메모리 접근 요청 및 변환된 물리 주소를 출력하여 변환 과정의 결과를 확인한다.

## 응용과제 5-1) 물리 메모리의 읽기/쓰기 요청

물리 메모리는 데이터 저장과 읽기/쓰기 요청을 구분하여 처리한다. 사용자가 특정 메모리 주소에 대해 읽기 또는 쓰기 요청을 수행하는 과정을 구현해 보자. 이를 위해 가상의 물리 메모리를 부모 프로세스에 할당하고, 자식 프로세스가 요청하는 읽기 또는 쓰기 요청이 실제로 어떻게 처리되는지 확인한다.

## 응용과제 5-2) 디맨드 페이징

디맨드 페이징을 추가해 보자. 부모 프로세스는 사용되지 않은 물리 메모리 영역을 리스트 또는 비트맵 형태로 관리한다. 이 자료구조는 프리 리스트 혹은 프리 프레임 맵이라 불린다.

초기 상태에서는 전체 물리 메모리가 비어 있으며, 각 프로세스의 페이지 테이블도 비어 있다. 프로세스가 메모리 접근을 요청하면 다음과 같이 처리한다.

    1. 페이지 테이블의 내용이 있는 경우 가상 주소를 물리 주소로 변환하여 결과를 출력한다.  

    2. 페이지 테이블에 해당 주소 정보가 없는 경우 프리 리스트 또는 프리 프레임 맵에서 사용되지 않은 페이지 프레임을 선택한다. 페이지 테이블에 매핑을 추가한 후 물리 주소로 변환하여 결과를 출력한다.

이처럼 필요한 페이지가 실제로 요청될 때 매핑하는 기법을 디맨드 페이징이라 한다. 디맨드 페이징을 통해 실제 페이지 사용량을 얼마나 줄일 수 있는지 확인해 보자.

## 응용과제 5-3) 2단계 페이징

2단계 페이징을 적용해 보자. PCB가 가리키는 페이지 테이블의 크기는 주소 공간의 크기에 비례한다. 예를 들어, 32비트 주소 공간에서는 2^32개의 엔트리를 가지는 매우 큰 배열이 된다.

이를 해결하기 위해 2단계 페이징을 사용해 페이지 테이블의 크기를 최적화할 수 있다. 1단계 페이지와 2단계 페이지의 인덱스 비트 크기는 임의로 설정할 수 있다. 설정 값에 따라 성능과 메모리 사용량이 달라지므로 각 방식의 장/단점을 분석하여 최적의 구조를 설계해 보자.

더 큰 주소 공간을 다루거나, 페이지 테이블 크기를 추가로 줄이기 위해 4단계 또는 5단계 페이징 구조를 설계할 수 있다. 4단계나 5단계 페이징을 사용한다면, 페이징 구조를 어떻게 설계할 것인가? 기존 시스템의 문제점과 현재까지 제시된 해결책들을 찾아보자.

## 응용과제 5-4) 스와핑

스와핑 기능을 추가해 보자. 가상 메모리는 물리 메모리 크기를 초과하는 논리적 메모리 매핑을 지원한다.

스와핑 기법을 적용하여 물리 메모리 용량을 초과하는 메모리 접근 시 디스크를 활용할 수 있도록 한다. 부모 프로세스는 특정 파일을 디스크로 가정하고, 읽기/쓰기를 통해 스와핑 연산을 구현할 수 있다.

프로세스의 주소 공간의 일부 페이지를 스와핑 아웃할 때는, 나중에 다시 사용할 수 있도록 저장된 영역에 대한 정보를 함께 보관해야 한다.
