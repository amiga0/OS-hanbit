# 실습과제 3장 프로세스

## 실습과제 1\) fork()/execve() 시스템콜을 이용한 간단한 셸 구현

fork()와 exec() 시스템콜을 이용해 다음 기능을 갖춘 간단한 셸을 구현한다.

1\) 사용자의 입력을 받는다.  
2\) 입력받은 프로그램을 실행힌다.

execve() 시스템콜은 입력으로 실행할 프로그램의 경로와 프로그램의 실행에 필요한 인자를  배열 형태로 입력받는다. 일반적으로 C 프로그램의 main() 함수는 두 개의 입력 인자를 가지며, 실행을 끝나면 정상 종료 또는 에러 상태를 반환한다.

main 함수의 원형과 인자는 다음과 같다.

```c
int main(int argc, char *argv[]);
```

- argc : 정수형으로, 입력된 인자의 개수를 나타냄
- argv: 문자형 배열의 포인터로, 입력된 인자들을 담고 있는 벡터 배열

사용자로부터 입력받은 문자열을 적절한 인자 배열 형태로 변환하여 execve()에 전달하면 /bin/ls, /bin/cp,  /usr/bin/gcc 등의 프로그램을 실행할 수 있다.

main() 함수가 종료되면 해당 프로그램의 실행도 종료된다. 그러나 셸이 지속적으로 동작하며 새로운 프로그램을 실행하기 위해서는 내부적으로 다음 두 개의 프로세스를 운영해야 한다.

부모 프로세스는 자식 프로세스가 실행한 프로그램이 종료될 때까지 대기하며, 이를 위해 wait() 시스템콜을 사용한다.

- 부모 프로세스: 사용자의 입력을 받아 처리한다.
- 자식 프로세스: execve()를 통해 입력받은 프로그램을 실행한다.

wait() 및 fork() 시스템콜을 활용하여 부모-자식 프로세스 관계를 형성하고, 실행한 프로그램이 정상적으로 종료되었는지 반환값을 확인하는 셸 프로그램을 작성해보자.

### 응용과제 1-1) PATH 환경 변수 활용

execve() 시스템콜은 실행할 프로그램의 전체 경로명을 첫 번째 인자로 받는다. 그러나 매번 전체 경로를 입력하는 것은 번거롭기 때문에, 대부분의 셸은 PATH 환경 변수를 활용하도록 수정해보자.

PATH 환경 변수는 여러 디렉터리 경로를 저장하는 문자열로, 사용자가 프로그램의 파일 이름만 입력하면, 셸은 PATH에 지정된 디렉터리를 검색하여 해당 프로그램의 전체 경로 를 자동으로 구성하고 실행한다.

셸이 환경 변수를 가져오고 실행할 프로그램의 경로를 찾기 위해 다음과 같은 함수를 사용할 수 있다.

- getenv() : PATH 환경 변수를 포함한 셸의 환경 변수를 가져옴
- strtok() : PATH에 저장된 여러 디렉터리를 분리하여 개별 경로를 추출하여 디렉터리 이름 생성
- open() 또는 stat(): 실제 해당 경로에 파일이 있는지 확인

### 응용과제 1-2) 파이프를 이용한 프로그램 연결

부모 프로세스와 자식 프로세스 간 데이터를 전달하는 방법으로 파이프(IPC, Inter-Process Communication)를 활용하도록 수정해보자.

셸에서 |(파이프 연산자)를 사용하면, 앞쪽 프로그램의 출력을 뒤쪽 프로그램의 입력으로 전달할 수 있다. 이는 pipe() 시스템 콜을 활용해 간단히 구현할 수 있다.

## 실습과제 2\) CPU 스케줄링 구현

타이머 인터럽트를 기반으로 동작하는 CPU 스케줄링을 구현해보자. 이를 위해 fork() 시스템콜을 사용해 자식 프로세스를 10개 생성한다.

- 부모 프로세스: 커널 역할을 한다.  
- 자식 프로세스: 사용자 프로세스 역할을 한다.

실제 커널이 하드웨어 타이머를 사용해 프로세스를 관리하는 것처럼, 부모 프로세스는 일정한 시간 간격으로 타이머 시그널을 받아야 한다. 이를 위해 다음 시스템콜을 활용한다.

- setitimer(): 일정한 간격으로 타이머 시그널을 생성한다.  
- sigaction(): 타이머 시그널을 처리하는 핸들러를 설정한다.

부모 프로세스는 여러 자식 프로세스 중 다음 CPU 버스트에 실행할 프로세스를 선택(스케줄링)하여 해당 프로세스에 시그널을 보낸다. 시그널 전송에는 kill() 시스템콜을 사용한다.

각 자식 프로세스는 CPU 버스트 시간을 cpu\_burst 변수에 저장하며 다음과 같이 동작한다.

- 기본적으로 sleep() 상태로 대기한다.  
- 부모 프로세스가 선택하여 시그널을 보내면 실행을 시작한다.  
- 실행할 때마다 cpu\_burst 값을 1씩 감소시킨다.  
- cpu\_burst가 0이 되면 실행을 종료한다(exit() 또는 return 사용).  
- 초기  cpu\_burst 값은 임의로 설정할 수 있다.

부모 프로세스는 라운드로빈 스케줄링 정책을 사용하며 자식 프로세스의 실행 순서를 관리하는 PCB(Process Control Block)를 다음과 같이 유지한다.

- 각 프로세스의 남은 CPU 버스트 값을 저장한다.  
- 모든 프로세스에게 동일한 CPU 버스트를 부여한다.  
- 타이머 인터럽트 발생 시 현재 실행 중인 프로세스의 CPU 버스트를 1씩 감소시킨다.  
- CPU 버스트가 남아있는 다음 프로세스를 선택하여 실행한다.  
- 모든 프로세스의 CPU 버스트가 0이 되면 CPU 버스트를 초기화한다.

구현한 라운드로빈 스케줄링에 대해 다음 성능 지표를 분석해보자.

- 시간에 따라 평균 대기 시간: 각 프로세스가 실행되기까지의 평균 대기 시간 계산한다.  
- 최대 응답 시간: 프로세스가 처음 실행될 때까지의 최대 대기 시간을 측정한다.  
- 공평성: 모든 프로세스가 CPU를 공평하게 할당받았는지 평가한다.

### 응용과제 2-1) CPU-I/O 버스트 시뮬레이션

실제 프로세스는 CPU와 I/O 작업을 번갈아 가며 실행된다. 이를 반영하여 CPU 버스트가 끝난 후 I/O 요청이 발생하는 상황을 추가해 보자. I/O 요청 처리 흐름은 다음과 같다.

- 자식 프로세스는 CPU 버스트가 0이 되면, 부모 프로세스에게 시그널을 보내어 I/O 요청을 발생시킨다.  
- 부모 프로세스는 I/O 요청을 받은 자식 프로세스를 스케줄링에서 제외하고 대기 큐로 이동시킨다.
- 자식 프로세서는 대기 큐에서 I/O 버스트만큼 대기한다.  
- I/O 작업이 완료되면 부모 프로세스는 해당 자식 프로세스를 다시 스케줄링 큐로 가져온다.  
- CPU 버스트와 I/O 버스트 값은 랜덤하게 지정한다.

### 응용과제 2-2) CPU 버스트 크기에 따른 결과 분석

CPU 버스트의 크기는 라운드로빈 스케줄링에서 중요한 매개변수로, 스케줄링의 효율성과 성능에 직접적인 영향을 미친다. CPU 버스트의 크기에 따른 결과(평균 대기시간, 응답시간, 공평성)를 비교하고 이론적으로 예측한 결과와 실험 결과가 일치하는지 확인해 본다.

### 응용과제 2-3) 다양한 스케줄링 구현

라운드로빈 스케줄링 외의 다음과 같이 다양한 스케줄링을 구현해 보자. FIFO, SJF, MLQ 등을 구현하고, 스케줄링 별로 평균 대기시간, 응답시간, 공평성을 비교 분석해 보자.

- FIFO(First In, First Out): 먼저 도착한 프로세스부터 순차적으로 실행한다.  
- SJF(Shortest Job First): 실행 시간이 가장 짧은 프로세스를 우선 실행한다.  
- MLQ(Multilevel Queue): 여러 개의 큐를 사용하여 프로세스를 우선순위에 따라 분류 하고고 스케줄링한다.
