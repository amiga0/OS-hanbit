### 📌 답 1️⃣  
먼저 모든 프로세스의 상태를 파악한다.  
다음으로 프로세스가 준비 상태이면 준비 큐에, 대기 상태이면 대기 큐에 분배하는 작업을 한다.  

---

### 📌 답 2️⃣  
FCFS의 장점은 알고리즘을 구현하기가 쉽다는 것이다.  
하지만 프로세스 간 실행의 공평성이나 응답 시간, 처리량, 대기 시간 등의 측면을 고려하지 않으므로,  
이러한 측면에서 최적의 스케줄링은 아니다.  

---

### 📌 답 3️⃣  
우선순위 스케줄링의 단점은 우선순위에서 자꾸 밀려 영영 처리될 수 없는 프로세스가 생겨날 가능성이 있다는 것이다.  
해결 방법은 시스템 내에 오랫동안 머물렀던 작업들의 우선순위를 높여주는 에이징(aging)을 구현하는 것이다.  

---

### 📌 답 4️⃣  
대기 상태에서 벗어나는 것은 정해진 순위에 의해서가 아니라  
대기 상태로 머물러야 했던 조건에 달렸기 때문이다.  
이 조건이 해결되면 다시 실행 상태로 돌아가는 것이므로 대기 상태에는 순위가 없다.  

---

### 📌 답 5️⃣  
라운드 로빈은 하나의 프로세스가 CPU를 독점하지 못하도록 타임퀀텀을 정해놓는다.  
프로세스가 타임퀀텀을 다 썼는데도 완료되지 않으면 그 프로세스를 준비 큐의 맨 뒤로 놓는다.  
이러한 과정을 통해 한 프로세스가 CPU 사용 시간을 다른 프로세스보다 무리하게 많이 사용하는 상황을 방지하고,  
프로세스가 많아지는 경우 응답 시간이 일정한 수준 이하로 유지될 수 있도록 한다.  

---

### 📌 답 6️⃣  
극단적으로 타임퀀텀이 매우 크다면 라운드 로빈은 FCFS와 다를 바가 없다.  
따라서, 응답 시간을 일정하게 보장받을 수 없다.  
반면, 타임퀀텀이 매우 짧다면, 프로세스의 유효한 실행시간이 줄어들고, 대기시간이 길어진다.  
또한, 문맥교환의 오버헤드도 매우 커질 수 있다.  

---

### 📌 답 7️⃣  
스케줄링 요구사항이 유사한 작업들끼리 모아 같은 클래스로 구성하여  
클래스마다 각각의 큐를 구성한다.  
스케줄러는 이러한 큐들 중에서 우선순위가 가장 높은 큐에서 프로세스를 선택하여 실행한다.  

---

### 📌 답 8️⃣  
CPU 활용률 관점에서 가장 효율적인 스케줄링은 FCFS다.  
FCFS는 비선점형 스케줄링 방식으로 프로세스가 한 번 시작하면,  
문맥전환이 없이 실행한 프로세스가 종료될 때까지 계속해서 작업이 수행되기 때문에  
프로세스 스케줄링에 따른 오버헤드가 적다.  
따라서 CPU의 낭비가 가장 적은 스케줄링이 된다.  

---

### 📌 답 9️⃣  
프로세스의 평균 응답 시간이 짧아지려면 모든 프로세스가 응답되기까지 기다리는 시간이 적어야 한다.  
이를 위해서는 작은 타임퀀텀을 가진 라운드 로빈 스케줄링이 유리하다.  
