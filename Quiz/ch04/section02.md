### 📌 답 1️⃣  
메모리 버퍼를 채우는 쓰레드와 실제 장치에서 I/O를 처리하는 쓰레드를 분리하여  
병렬적으로 처리할 수 있기 때문이다.  
즉, 장치에서 I/O를 처리하는 동안 CPU에서는 다음 I/O를 위한 데이터를 지속적으로 생성할 수 있다.  
반면, 단일 쓰레드만을 사용한다면 장치의 I/O 작업이 완료될 때까지  
프로세스는 다음 I/O를 위한 데이터를 생성할 수 없다.  

---

### 📌 답 2️⃣  
메모리 버퍼에 데이터를 채우는 속도와 장치의 I/O 속도에 따라  
둘이 비슷한 비율을 갖도록 쓰레드의 수를 조정하는 것이 좋다.  

---

### 📌 답 3️⃣  
커널이 사용자 쓰레드를 직접 스케줄링하는 것과 동일한 효과를 나타낸다.  
또한 많은 사용자 쓰레드를 가지는 프로세스는  
다른 프로세스에 비해 많은 CPU 타임퀀텀을 가진다.  

---

### 📌 답 4️⃣  
사용자 쓰레드의 TCB는 사용자 프로세스상에 존재해야 한다.  
쓰레드 라이브러리에서 사용자 쓰레드 TCB를 관리한다.  
커널 쓰레드의 TCB는 커널의 PCB 내에 존재한다.  

---

### 📌 답 5️⃣  
쓰레드 스위칭은 쓰레드가 다른 쓰레드와 공유하지 않는 영역만 저장하면 된다.  
즉, 프로그램 카운터, 스택 포인터, 기타 CPU 레지스터들이 저장된다.  
반면, 프로세스 스위칭은 쓰레드 스위칭에서 저장되는 정보 외에도  
파일 정보, 메모리 정보 등 더 많은 데이터를 저장해야 한다.  

---

### 📌 답 6️⃣  
아래는 주기적으로 인터럽트를 발생시키고,  
T1이 T2에게 시그널을 보내는 쓰레드 코드이다.  

```c
int main() {
    T1 = create_thread();
    T2 = create_thread();

    while(1) { 
        alarm(10ms);  // 주기적으로 인터럽트를 발생시킴
    }
}

T1() {
    SignalRegister(SIGALRM, SignalHandlerT1);
    while(1) { 
        sigpause(SIGALRM); 
    }
}

SignalHandlerT1(signal) { // 여기 시그널 확인은 불필요하나
    if(signal == SIGALRM) { // 의미를 분명히 하기 위해 넣음
        Kill(T2, SIGUSR1);  // T2에 SIGUSR1을 보냄
    }
}

T2() {
    SignalRegister(SIGUSR1, SignalHandlerT2);
    while(1) { 
        sigpause(SIGUSR1); 
    }
}

SignalHandlerT2(signal) { 
    if(signal == SIGUSR1) {
        Schedule();
    }
}
