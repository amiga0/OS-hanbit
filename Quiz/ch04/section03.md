#### 📌 답 1️⃣  
경쟁 조건이 발생하지 않도록 한다.  
경쟁 조건은 쓰레드의 스케줄링 순서에 따라 결과가 다르게 나타나는 상황을 의미한다.  
경쟁 조건을 없애기 위해서는 쓰레드가 동시에 공유하는 자원에 대한 접근을 수행하는 코드에 대해  
임계 영역을 설정하고, 여러 쓰레드 간 임계 영역의 실행을 동기화하여  
하나의 쓰레드만 임계 영역에서 처리되도록 보장해야 한다.  

---

#### 📌 답 2️⃣  
다중 쓰레드의 동기화의 문제로 인해 모든 쓰레드가 임계 영역에 들어가지 못하고  
대기하며 실행을 진행하지 못하는 상태에 빠진 것을 의미한다.  

---

#### 📌 답 3️⃣  
임계 영역 안에 오직 하나의 쓰레드만 존재하도록 하기 위해서다.  

---

#### 📌 답 4️⃣  
세마포는 프로그램 안에서 명시적으로 사용함으로써 동기화를 달성한다.  
반면, 모니터는 프로그램에서 임계 영역을 선언하고,  
외부(예: 데이터베이스 관리 시스템)에서 임계 영역에 대한 동기화를 제공해 준다.  

---

#### 📌 답 5️⃣  
상호배제를 사용하는 경우 읽기와 쓰기를 구분하지 않아서  
공유된 데이터에 접근하기 위하여 1개의 읽기 또는 쓰기가 접근한다.  
그러나 읽기도 한 번에 하나씩만 접근이 허락된다는 것이 단점이다.  

---

#### 📌 답 6️⃣  
스핀락은 임계 영역에 들어갈 수 있는지 지속적으로 체크하는 것이다.  
따라서 CPU와 버스 자원을 낭비하게 되는 단점이 있다.  
그러나 멀티코어 시스템에서 잠깐 스핀락을 사용하고 임계 영역에 들어가는 경우에는  
스핀락이 오히려 효과적이다.  

---

#### 📌 답 7️⃣

##### 동기화 알고리즘 설계

1) 각각의 쓰레드는 각 점에 대해, 미리 `up`, `down`, `left`, `right`를 검사하여 주위 4개의 점에 모두 쓰기(write)가 없을 때  
   4개의 점을 읽고(read) 점수를 계산 및 합산하여 점 `(i, j)`에 쓰기(write)를 한다.  
   _(각 쓰레드는 하나의 세로줄을 관리한다. 쓰레드 번호를 `i`, 가로줄 번호를 `j`라 한다.)_

2) 각 점에 대해 하나의 쓰레드만이 쓰기(write)를 할 수 있고, 각 점에 하나의 읽기(read)가 있다면 쓰기(write)를 할 수 없다.

3) 문제 해결을 위한 자료구조 및 초기화  

   ###### A. Semaphore `sem[i][j]` - 쓰레드[`i`]가 점(`i, j`)에 쓰기(write)를 하기 위한 세마포  
   [초깃값: 0]

   ```c
   take_4_points(i, j) {
       // mutex를 통해 state에 접근
       p(mutex);

       // 점 (i, j) 사방의 점들의 state를 검사, 쓰기가 없다면 state 변경 및 v(sem)
       test(i, j);

       v(mutex);

       // 점(i, j) 사방의 점에 쓰기가 없을 때까지 대기
       p(sem[i][j]);
   }

put_4_points(i, j) {
    // mutex를 통해 state에 접근
    p(mutex);

    // state 변경
    state[i][j] = writing;

    // 사방의 점을 확인하여 p(sem)으로 대기 중인 쓰레드에 v() 전달
    test(i, j-1);
    test(i, j+1);
    test(i-1, j);
    test(i+1, j);

    v(mutex);
}





















#### 🔹 동기화 알고리즘 설계  
1️⃣ 각각의 쓰레드는 각 점에 대해, 미리 `up`, `down`, `left`, `right`를 검사하여  
   주위 4개의 점에 모두 쓰기(`write`)가 없을 때 4개의 점을 읽고(`read`)  
   점수를 계산 및 합산하여 점 `(i, j)`에 쓰기(`write`)를 한다.  
   (각 쓰레드는 하나의 세로줄을 관리한다. 쓰레드 번호를 `i`, 가로줄 번호를 `j`라 한다.)  

2️⃣ 각 점에 대해 하나의 쓰레드만이 쓰기(`write`)를 할 수 있고,  
   각 점에 하나의 읽기(`read`)가 있다면 쓰기(`write`)를 할 수 없다.  

3️⃣ 문제 해결을 위한 자료구조 및 초기화

##### A. semaphore sem[i][j] – 쓰레드[i]가 점(i, j)에 쓰기(write)를 하기 위한 세마포 
       [ 초기값: 0 ] 

### 📌 함수 정의  

```c
// take_4_points(i, j) 함수
void take_4_points(int i, int j) {  
    // mutex를 통해 state에 접근  
    p(mutex);  
    // 점(i, j) 사방의 점들의 state를 검사  
    // 쓰기가 없다면 state 변경 및 v(sem)  
    test(i, j);  
    v(mutex);  
    // 점(i, j) 사방의 점에 쓰기가 없을 때까지 대기  
    p(sem[i][j]);  
}

// put_4_points(i, j) 함수
void put_4_points(int i, int j) {  
    // mutex를 통해 state에 접근  
    p(mutex);  
    // state 변경  
    state[i][j] = !writing;  
    // 사방의 점을 확인하여 p(sem)으로 대기 중인 쓰레드에 v() 전달  
    test(i, j-1);  
    test(i, j+1);  
    test(i-1, j);  
    test(i+1, j);  
    v(mutex);  
}



##### B. bool state[i][j] –점(i,j)가 쓰기 상태인지 아닌지를 저장(쓰기 상태 일 때 state[i][j] = writing)  
      [ 초기값: !writing ]


##### C. semaphore mutex – state를 관리하기 위한 세마포
      [ 초기값: 1 ]


#### 🔹 쓰레드와 동기화 알고리즘의 의사코드

쓰레드 I –
for(j=0 ; j<10 ; j++) {
	// 점(i, j) 사방에 write가 없을 때까지 p(sem[i, j])로 대기
	take_4_points(i, j)
		…read 4 points and calculate
		…write at (i, j)
	// 점(i, j) 사방의 점들에 대해, p(sem)으로 대기중인 쓰레드에 v()전달
	put_4_points(i, j)
} // for j



void test(int i, int j) {
    // 점(i, j) 사방의 점들의 state를 확인
    if (state[i][j-1] != writing &&
        state[i][j+1] != writing &&
        state[i-1][j] != writing &&
        state[i+1][j] != writing) {
        // 점(i,j) 사방의 점들에 쓰기가 없다면 상태 변경 및 대기 중인 쓰레드 해제
        state[i][j] = writing;
        v(sem[i][j]);
    }
}


